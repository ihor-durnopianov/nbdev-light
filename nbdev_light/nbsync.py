#!/usr/bin/env python3.6
# -*- coding: utf-8 -*-
# GENERATED BY NBSYNC.  MODIFY AT YOUR OWN RISK.
"""Simple tool to facilitate explorative programming."""


import argparse
import logging
import pathlib
import re
import json


REGEX = "^#[ ]*export[ ]*(?P<filename>[\/A-Za-z0-9._-]+.py)(:(?P<number>[0-9.]+))?$"


def main():
    """Entry point of the application."""
    args = _Parser().specify_args().parse_args()
    logging.basicConfig(level="INFO", format="%(levelname)s - %(message)s")
    logger = logging.getLogger(__name__)
    logger.info("processing %s", args.notebook)
    cells = _extract_relevant_cells(args.notebook)
    files = _sort_cells_by_files(cells)
    for filename, cells in files.items():
        if args.dest.is_dir():
            dest = args.dest / filename
        else:
            if args.dest.name == filename.name:
                dest = args.dest
            else:
                logger.info(
                    "only %s chosen, skippin' %s", args.dest, filename
                )
                continue
        if args.interactive:
            if not input(
                "Processing %s, enter y to proceed: " % dest
            ) == "y":
                logger.info("skippin' %s", dest)
                continue
        # TODO: refactor out filename
        content = _assemble_file(
            cells, args.shebang, args.main, args.docstring, filename
        )
        if dest.exists() and not args.force:
            logger.info("%s exists, skippin'", dest)
            continue
        with open(dest, "w") as file:
            file.write(content)
        logger.info("written %s", dest)


class _Parser(argparse.ArgumentParser):

    def specify_args(self):
        self.add_argument("notebook")
        class _ConvertToPath(argparse.Action):
            """"""

            def __call__(self, _, args, arg, ___):
                result = pathlib.Path(arg)
                setattr(args, self.dest, result)
        self.add_argument(
            "dest", help="directory of file", action=_ConvertToPath
        )
        self.add_argument("-f", "--force", action="store_true")
        self.add_argument("-s", "--shebang", action="store_true")
        self.add_argument("-m", "--main", action="store_true")
        self.add_argument("-i", "--interactive", action="store_true")
        self.add_argument("-d", "--docstring", help=(
            "override module docstring.  Worth noting that: 1. \"does the "
            "right thing\" for one-liners only, 2. applies to all targets, 3. "
            "sets cell number to 0"
        ))
        return self


def _merge(upper, *args):
    return (
        "# -*- coding: utf-8 -*-\n"
        + "# GENERATED BY NBSYNC.  MODIFY AT YOUR OWN RISK.\n"
        + "\n\n\n".join(
            "".join(cell["source"][1:]) for cell in upper
        )
        + "\n"
    )


def _assemble_file(cells, shebang, main, docstring=None, filename=None):
    upper = _find_upper_level_exports(cells)
    if docstring is not None:
        upper = _set_docstring(upper, docstring, filename)
    content = _merge(_reorder(upper))
    if shebang:
        content = "#!/usr/bin/env python3.6\n" + content
    if main:
        content += '\n\nif __name__ == "__main__":\n    main()\n'
    return content


def _find_docstring_cell(cells):
    return next((cell for cell in cells if cell["source"][1].startswith('"""')), None)


def _set_docstring(cells, docstring, filename):
    docstring_cell = _find_docstring_cell(cells)
    if docstring_cell is None:
        return [{"source": [
            "# export %s:0\n" % filename,
            '"""%s"""' % docstring
        ]}] + cells
    docstring_cell["source"] = (
        docstring_cell["source"][:1] + ['"""%s"""' % docstring]
    )
    return cells


def _reorder(cells):
    regex = re.compile(REGEX)
    def _define_number(cell):
        number = regex.match(cell["source"][0]).group("number")
        if number is None:
            return None
        return float(number)
    if all(_define_number(cell) is not None for cell in cells):
        return sorted((cell for cell in cells), key=_define_number)
    # Hopefully
    docstring = _find_docstring_cell(cells)
    imports = [cell for cell in cells if cell["source"][1].startswith('import') or cell["source"][1].startswith('from')]
    constants = [cell for cell in cells if cell["source"][1].split()[0].isupper()]
    main = next((cell for cell in cells if next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("def main")), None)
    public_classes = [
        cell for cell in cells
        if (
            next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("class ")
            and not next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("class _")
        )
    ]
    public_functions = [
        cell for cell in cells
        if (
            next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("def ")
            and not next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("def _")
            and not next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("def main")
        )
    ]
    private_classes = [
        cell for cell in cells
        if next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("class _")
    ]
    private_functions = [
        cell for cell in cells
        if next(line for line in cell["source"][1:] if not line.startswith("@")).startswith("def _")
    ]
    ordered = []
    if docstring is not None:
        ordered.append(docstring)
    ordered.extend(imports)
    ordered.extend(constants)
    if main is not None:
        ordered.append(main)
    ordered.extend([*public_classes, *public_functions, *private_classes, *private_functions])
    ordered.extend([cell for cell in cells if cell not in ordered])
    return ordered


def _sort_cells_by_files(cells):
    files = {}
    regex = re.compile(REGEX)
    def _define_filename(cell):
        return pathlib.Path(regex.match(cell["source"][0]).group("filename"))
    for cell in cells:
        files.setdefault(_define_filename(cell), []).append(cell)
    return files


def _find_upper_level_exports(cells):
    regex = re.compile(REGEX)
    return [cell for cell in cells if regex.match(cell["source"][0]) is not None]


def _extract_relevant_cells(filename):
    with open(filename, "r", encoding="utf-8") as file:
        regex = re.compile(REGEX)
        return [
            cell
            for cell in json.load(file)["cells"]
            if (
                cell["cell_type"] == "code"
                and cell["source"]
                and regex.match(cell["source"][0]) is not None
            )
        ]


if __name__ == "__main__":
    main()
